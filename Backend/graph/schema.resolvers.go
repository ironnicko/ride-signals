package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.79

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"time"

	"github.com/ironnicko/ride-signals/Backend/db"
	"github.com/ironnicko/ride-signals/Backend/graph/model"
	"github.com/ironnicko/ride-signals/Backend/kafka"
	"github.com/ironnicko/ride-signals/Backend/models"
	"github.com/ironnicko/ride-signals/Backend/utils"
	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/bson/primitive"
	"go.mongodb.org/mongo-driver/mongo"
	"go.mongodb.org/mongo-driver/mongo/options"
)

// CreateRide is the resolver for the createRide field.
func (r *mutationResolver) CreateRide(ctx context.Context, maxRiders int, visibility string) (*model.Ride, error) {
	userId := ctx.Value("userId").(string)
	participants := []*model.Participant{
		{
			UserID:   userId,
			Role:     "leader",
			JoinedAt: time.Now().UTC().Format(time.RFC3339),
		},
	}

	ride := &model.Ride{
		ID:       primitive.NewObjectID().Hex(),
		RideCode: utils.GenRideCode(),
		Status:   "active",
		Settings: &model.RideSettings{
			MaxRiders:  maxRiders,
			Visibility: visibility,
		},
		Participants: participants,
		CreatedAt:    time.Now().UTC().Format(time.RFC3339),
		CreatedBy:    userId,
	}

	coll := db.GetCollection("bikeapp", "rides")
	_, err := coll.InsertOne(ctx, ride)
	if err != nil {
		return nil, err
	}
	return ride, nil
}

// JoinRide is the resolver for the joinRide field.
func (r *mutationResolver) JoinRide(ctx context.Context, rideCode string, role string) (*model.Ride, error) {
	userIdVal := ctx.Value("userId")
	if userIdVal == nil {
		return nil, errors.New("unauthorized: no userId in context")
	}

	userIdHex, ok := userIdVal.(string)
	if !ok {
		return nil, errors.New("invalid userId type in context")
	}

	userID, err := primitive.ObjectIDFromHex(userIdHex)
	if err != nil {
		return nil, fmt.Errorf("invalid userId format: %w", err)
	}

	coll := db.GetCollection("bikeapp", "rides")

	var ride model.Ride
	err = coll.FindOne(ctx, bson.M{"rideCode": rideCode}).Decode(&ride)
	if err != nil {
		if err == mongo.ErrNoDocuments {
			return nil, fmt.Errorf("ride not found")
		}
		return nil, fmt.Errorf("failed to fetch ride: %w", err)
	}

	for _, p := range ride.Participants {
		if p.UserID == userID.Hex() {
			return &ride, nil
		}
	}

	if len(ride.Participants) >= ride.Settings.MaxRiders {
		return nil, fmt.Errorf("ride is full: max riders = %d", ride.Settings.MaxRiders)
	}

	participant := model.Participant{
		UserID:   userID.Hex(),
		Role:     role,
		JoinedAt: time.Now().UTC().Format(time.RFC3339),
	}

	update := bson.M{"$push": bson.M{"participants": participant}}
	res := coll.FindOneAndUpdate(
		ctx,
		bson.M{"rideCode": rideCode},
		update,
		options.FindOneAndUpdate().SetReturnDocument(options.After),
	)

	var updatedRide model.Ride
	if err := res.Decode(&updatedRide); err != nil {
		return nil, fmt.Errorf("failed to decode updated ride: %w", err)
	}

	return &updatedRide, nil
}

// SendSignal is the resolver for the sendSignal field.
func (r *mutationResolver) SendSignal(ctx context.Context, rideCode string, signalType string, lat *float64, lng *float64) (bool, error) {
	sig := model.Signal{
		ID:        primitive.NewObjectID().Hex(),
		RideCode:  rideCode,
		Type:      signalType,
		Timestamp: time.Now().UTC().Format(time.RFC3339),
	}

	if lat != nil && lng != nil {
		sig.Location = &model.GeoLocation{Lat: *lat, Lng: *lng}
	}

	coll := db.GetCollection("bikeapp", "signals")
	_, err := coll.InsertOne(ctx, sig)
	if err != nil {
		return false, err
	}

	msg, _ := json.Marshal(sig)
	if err := kafka.PublishSignal(rideCode, msg); err != nil {
		return false, err
	}

	return true, nil
}

// Me is the resolver for the me field.
func (r *queryResolver) Me(ctx context.Context) (*model.User, error) {
	var dbUser models.User
	coll := db.GetCollection("bikeapp", "users")

	userId := ctx.Value("userId").(string)
	oid, err := primitive.ObjectIDFromHex(userId)
	if err != nil {
		return nil, errors.New("userId invalid")
	}

	err = coll.FindOne(ctx, bson.M{"_id": oid}).Decode(&dbUser)
	if err != nil {
		if err == mongo.ErrNoDocuments {
			return nil, errors.New("user not found")
		}
		return nil, err
	}

	return &model.User{
		ID:    dbUser.ID.Hex(),
		Name:  dbUser.Name,
		Email: dbUser.Email,
	}, nil
}

// Ride is the resolver for the ride field.
func (r *queryResolver) Ride(ctx context.Context, rideCode string) (*model.Ride, error) {
	coll := db.GetCollection("bikeapp", "rides")
	var ride model.Ride
	err := coll.FindOne(ctx, bson.M{"rideCode": rideCode}).Decode(&ride)
	if err != nil {
		return nil, err
	}
	return &ride, nil
}

// MyRides is the resolver for the myRides field.
func (r *queryResolver) MyRides(ctx context.Context) ([]*model.Ride, error) {
	userID := ctx.Value("userId").(string)
	coll := db.GetCollection("bikeapp", "rides")
	cursor, err := coll.Find(ctx, bson.M{"participants.userId": userID})
	if err != nil {
		return nil, err
	}
	defer cursor.Close(ctx)

	var rides []*model.Ride
	for cursor.Next(ctx) {
		var ride model.Ride
		if err := cursor.Decode(&ride); err != nil {
			return nil, err
		}
		rides = append(rides, &ride)
	}
	return rides, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
