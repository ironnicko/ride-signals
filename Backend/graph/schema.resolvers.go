package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.79

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"time"

	"github.com/ironnicko/ride-signals/Backend/db"
	"github.com/ironnicko/ride-signals/Backend/graph/model"
	"github.com/ironnicko/ride-signals/Backend/kafka"
	"github.com/ironnicko/ride-signals/Backend/models"
	"github.com/ironnicko/ride-signals/Backend/utils"
	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/bson/primitive"
	"go.mongodb.org/mongo-driver/mongo"
	"go.mongodb.org/mongo-driver/mongo/options"
)

// CreateRide is the resolver for the createRide field.
func (r *mutationResolver) CreateRide(ctx context.Context, maxRiders int, visibility string, startLat float64, startLng float64, destinationLat float64, destinationLng float64, startName string, destinationName string) (*model.Ride, error) {
	userId := ctx.Value("userId").(string)
	participants := []*model.Participant{
		{
			UserID:   userId,
			Role:     "leader",
			JoinedAt: time.Now().UTC().Format(time.RFC3339),
		},
	}

	startLocation, err := getGeoLocation(&startLat, &startLng)
	if err != nil {
		return nil, fmt.Errorf("invalid start location: %w", err)
	}

	destinationLocation, err := getGeoLocation(&destinationLat, &destinationLng)
	if err != nil {
		return nil, fmt.Errorf("invalid destination location: %w", err)
	}

	ride := &model.Ride{
		RideCode: utils.GenRideCode(),
		Status:   "not started",
		Settings: &model.RideSettings{
			MaxRiders:  maxRiders,
			Visibility: visibility,
		},
		Participants:    participants,
		CreatedAt:       time.Now().UTC().Format(time.RFC3339),
		CreatedBy:       userId,
		Start:           startLocation,
		Destination:     destinationLocation,
		StartName:       startName,
		DestinationName: destinationName,
	}

	coll := db.GetCollection("bikeapp", "rides")
	_, err = coll.InsertOne(ctx, ride)
	if err != nil {
		return nil, err
	}
	return ride, nil
}

// UpdateRide is the resolver for the updateRide field.
func (r *mutationResolver) UpdateRide(ctx context.Context, rideCode string, maxRiders *int, visibility *string, endedAt *string, status *string) (*model.Ride, error) {
	userId := ctx.Value("userId").(string)

	coll := db.GetCollection("bikeapp", "rides")

	// Ensure the ride exists and belongs to the user
	var ride model.Ride
	err := coll.FindOne(ctx, bson.M{"ridecode": rideCode}).Decode(&ride)
	if err != nil {
		return nil, fmt.Errorf("ride not found: %w", err)
	}

	if ride.CreatedBy != userId {
		return nil, fmt.Errorf("unauthorized: you are not the owner of this ride")
	}

	update := bson.M{}
	if maxRiders != nil {
		update["settings.maxriders"] = *maxRiders
	}
	if visibility != nil {
		update["settings.visibility"] = *visibility
	}
	if endedAt != nil {
		update["endedat"] = *endedAt
	}
	if status != nil {
		update["status"] = *status
	}

	if len(update) == 0 {
		return &ride, nil // nothing to update
	}

	_, err = coll.UpdateOne(
		ctx,
		bson.M{"ridecode": rideCode},
		bson.M{"$set": update},
	)
	if err != nil {
		return nil, fmt.Errorf("failed to update ride: %w", err)
	}

	// Return the updated ride
	err = coll.FindOne(ctx, bson.M{"ridecode": rideCode}).Decode(&ride)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch updated ride: %w", err)
	}

	return &ride, nil
}

// JoinRide is the resolver for the joinRide field.
func (r *mutationResolver) JoinRide(ctx context.Context, rideCode string, role string) (*model.Ride, error) {
	userIdVal := ctx.Value("userId")
	if userIdVal == nil {
		return nil, errors.New("unauthorized: no userId in context")
	}

	userIdHex, ok := userIdVal.(string)
	if !ok {
		return nil, errors.New("invalid userId type in context")
	}

	userID, err := primitive.ObjectIDFromHex(userIdHex)
	if err != nil {
		return nil, fmt.Errorf("invalid userId format: %w", err)
	}

	coll := db.GetCollection("bikeapp", "rides")

	var ride model.Ride
	err = coll.FindOne(ctx, bson.M{"ridecode": rideCode}).Decode(&ride)
	if err != nil {
		if err == mongo.ErrNoDocuments {
			return nil, fmt.Errorf("ride not found")
		}
		return nil, fmt.Errorf("failed to fetch ride: %w", err)
	}

	for _, p := range ride.Participants {
		if p.UserID == userID.Hex() {
			return &ride, nil
		}
	}

	if len(ride.Participants) >= ride.Settings.MaxRiders {
		return nil, fmt.Errorf("ride is full: max riders = %d", ride.Settings.MaxRiders)
	}

	participant := model.Participant{
		UserID:   userID.Hex(),
		Role:     role,
		JoinedAt: time.Now().UTC().Format(time.RFC3339),
	}

	update := bson.M{"$push": bson.M{"participants": participant}}
	res := coll.FindOneAndUpdate(
		ctx,
		bson.M{"ridecode": rideCode},
		update,
		options.FindOneAndUpdate().SetReturnDocument(options.After),
	)

	var updatedRide model.Ride
	if err := res.Decode(&updatedRide); err != nil {
		return nil, fmt.Errorf("failed to decode updated ride: %w", err)
	}

	return &updatedRide, nil
}

// SendSignal is the resolver for the sendSignal field.
func (r *mutationResolver) SendSignal(ctx context.Context, rideCode string, signalType string, lat *float64, lng *float64) (bool, error) {
	userId := ctx.Value("userId").(string)
	sig := model.Signal{
		RideCode:  rideCode,
		FromUser:  userId,
		Type:      signalType,
		Timestamp: time.Now().UTC().Format(time.RFC3339),
	}

	var err error
	sig.Location, err = getGeoLocation(lat, lng)

	if err != nil {
		return false, err
	}

	coll := db.GetCollection("bikeapp", "signals")
	_, err = coll.InsertOne(ctx, sig)
	if err != nil {
		return false, err
	}

	msg, _ := json.Marshal(sig)
	if err := kafka.PublishSignal(rideCode, msg); err != nil {
		return false, err
	}

	return true, nil
}

// Me is the resolver for the me field.
func (r *queryResolver) Me(ctx context.Context) (*model.User, error) {
	var dbUser models.User
	coll := db.GetCollection("bikeapp", "users")

	userId := ctx.Value("userId").(string)
	oid, err := primitive.ObjectIDFromHex(userId)
	if err != nil {
		return nil, errors.New("userId invalid")
	}

	err = coll.FindOne(ctx, bson.M{"_id": oid}).Decode(&dbUser)
	if err != nil {
		if err == mongo.ErrNoDocuments {
			return nil, errors.New("user not found")
		}
		return nil, err
	}

	return &model.User{
		ID:          dbUser.ID.Hex(),
		Name:        dbUser.Name,
		Email:       dbUser.Email,
		CurrentRide: *dbUser.CurrentRide,
	}, nil
}

// Ride is the resolver for the ride field.
func (r *queryResolver) Ride(ctx context.Context, rideCode string) (*model.Ride, error) {
	coll := db.GetCollection("bikeapp", "rides")
	var ride model.Ride
	err := coll.FindOne(ctx, bson.M{"ridecode": rideCode}).Decode(&ride)
	if err != nil {
		return nil, err
	}
	return &ride, nil
}

// MyRides is the resolver for the myRides field.
func (r *queryResolver) MyRides(ctx context.Context) ([]*model.Ride, error) {
	userID := ctx.Value("userId").(string)
	coll := db.GetCollection("bikeapp", "rides")
	cursor, err := coll.Find(ctx, bson.M{"participants.userid": userID})
	if err != nil {
		return nil, err
	}
	defer cursor.Close(ctx)

	var rides []*model.Ride
	for cursor.Next(ctx) {
		var ride model.Ride
		if err := cursor.Decode(&ride); err != nil {
			return nil, err
		}
		rides = append(rides, &ride)
	}
	return rides, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
