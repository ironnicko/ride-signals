package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.81

import (
	"context"
	"errors"
	"fmt"
	"time"

	"github.com/ironnicko/ride-signals/Backend/db"
	"github.com/ironnicko/ride-signals/Backend/models"
	"github.com/ironnicko/ride-signals/Backend/utils"
	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/bson/primitive"
	"go.mongodb.org/mongo-driver/mongo"
	"go.mongodb.org/mongo-driver/mongo/options"
)

// --- CreateRide ---
func (r *mutationResolver) CreateRide(ctx context.Context, maxRiders int, visibility string, startLat float64, startLng float64, destinationLat float64, destinationLng float64, startName string, destinationName string, tripName string) (*models.Ride, error) {
	userIDHex := ctx.Value("userId").(string)
	userID, err := primitive.ObjectIDFromHex(userIDHex)
	if err != nil {
		return nil, fmt.Errorf("invalid userId: %w", err)
	}

	participants := []models.Participant{
		{
			UserID:   userID,
			Role:     "leader",
			JoinedAt: time.Now().UTC().Format(time.RFC3339),
		},
	}

	startLocation := models.GeoLocation{Lat: startLat, Lng: startLng}
	destLocation := models.GeoLocation{Lat: destinationLat, Lng: destinationLng}

	ride := &models.Ride{
		ID:              primitive.NewObjectID(),
		RideCode:        utils.GenRideCode(),
		Status:          "not started",
		CreatedAt:       time.Now().UTC().Format(time.RFC3339),
		Participants:    participants,
		Settings:        models.RideSettings{MaxRiders: maxRiders, Visibility: visibility},
		Start:           startLocation,
		Destination:     destLocation,
		StartName:       startName,
		DestinationName: destinationName,
		TripName:        tripName,
		CreatedBy:       userID,
	}

	coll := db.GetCollection("bikeapp", "rides")
	if _, err := coll.InsertOne(ctx, ride); err != nil {
		return nil, err
	}

	return ride, nil
}

// --- UpdateRide ---
func (r *mutationResolver) UpdateRide(ctx context.Context, rideCode string, requestType *string, maxRiders *int, visibility *string, endedAt *string, startedAt *string, status *string, tripName *string) (*models.Ride, error) {
	userIDHex := ctx.Value("userId").(string)
	userID, err := primitive.ObjectIDFromHex(userIDHex)
	if err != nil {
		return nil, fmt.Errorf("invalid userId: %w", err)
	}

	ridesColl := db.GetCollection("bikeapp", "rides")
	usersColl := db.GetCollection("bikeapp", "users")

	var ride models.Ride
	if err := ridesColl.FindOne(ctx, bson.M{"rideCode": rideCode}).Decode(&ride); err != nil {
		return nil, fmt.Errorf("ride not found: %w", err)
	}

	update := bson.M{}
	if maxRiders != nil {
		update["settings.maxRiders"] = *maxRiders
	}
	if visibility != nil {
		update["settings.visibility"] = *visibility
	}
	if startedAt != nil {
		update["startedAt"] = *startedAt
	}
	if endedAt != nil {
		update["endedAt"] = *endedAt
	}
	if status != nil {
		update["status"] = *status
	}
	if tripName != nil {
		update["tripName"] = *tripName
	}

	if len(update) > 0 {
		if _, err := ridesColl.UpdateOne(ctx, bson.M{"rideCode": rideCode}, bson.M{"$set": update}); err != nil {
			return nil, fmt.Errorf("failed to update ride: %w", err)
		}
	}

	if requestType != nil {
		switch *requestType {

		case "start":
			_, err = usersColl.UpdateOne(ctx,
				bson.M{"_id": userID},
				bson.M{"$set": bson.M{"currentRide": rideCode}},
			)
			if err != nil {
				return nil, fmt.Errorf("failed to update user: %w", err)
			}

			users, err := getUsersFromRideParticipants(ctx, ride, usersColl)
			if err != nil {
				return nil, fmt.Errorf("failed to get ride users: %w", err)
			}

			// Send notifications asynchronously
			go func(users []models.User) {
				for _, user := range users {
					if user.PushSubscription != nil {
						utils.SendNotification(
							user.PushSubscription,
							"Ride Started...",
							ride.TripName+" is starting now.",
							"./icon.png",
						)
					}
				}
			}(*users)

		case "join":
			_, err = usersColl.UpdateOne(ctx,
				bson.M{"_id": userID},
				bson.M{"$set": bson.M{"currentRide": rideCode}},
			)
			if err != nil {
				return nil, fmt.Errorf("failed to update user: %w", err)
			}

		case "end":
			_, err = usersColl.UpdateOne(ctx,
				bson.M{"_id": userID},
				bson.M{"$set": bson.M{"currentRide": ""}},
			)
			if err != nil {
				return nil, fmt.Errorf("failed to update user: %w", err)
			}

			users, err := getUsersFromRideParticipants(ctx, ride, usersColl)
			if err != nil {
				return nil, fmt.Errorf("failed to get ride users: %w", err)
			}

			go func(users []models.User) {
				for _, user := range users {
					if user.PushSubscription != nil {
						utils.SendNotification(
							user.PushSubscription,
							"Ride Ended...",
							ride.TripName+" has ended.",
							"./icon.png",
						)
					}
				}
			}(*users)

		case "remove":
			_, err = usersColl.UpdateOne(ctx,
				bson.M{"_id": userID},
				bson.M{"$set": bson.M{"currentRide": ""}},
			)
			if err != nil {
				return nil, fmt.Errorf("failed to update user: %w", err)
			}
		}
	}

	if err := ridesColl.FindOne(ctx, bson.M{"rideCode": rideCode}).Decode(&ride); err != nil {
		return nil, fmt.Errorf("failed to fetch updated ride: %w", err)
	}

	return &ride, nil
}

// UpdateUser is the resolver for the updateUser field.
func (r *mutationResolver) UpdateUser(ctx context.Context, input models.UpdateUserInput) (*models.User, error) {
	usersColl := db.GetCollection("bikeapp", "users")

	userIDHex := ctx.Value("userId").(string)
	userID, err := primitive.ObjectIDFromHex(userIDHex)
	if err != nil {
		return nil, fmt.Errorf("invalid userId: %w", err)
	}

	update := bson.M{}

	if input.Name != nil {
		update["name"] = *input.Name
	}
	if input.Email != nil {
		update["email"] = *input.Email
	}
	if input.IsActive != nil {
		update["isActive"] = *input.IsActive
	}
	if input.CurrentRide != nil {
		update["currentRide"] = *input.CurrentRide
	}
	if input.Picture != nil {
		update["picture"] = *input.Picture
	}
	if input.PushSubscription != nil {
		ps := input.PushSubscription
		psUpdate := bson.M{
			"endpoint": ps.Endpoint,
			"keys": bson.M{
				"p256dh": ps.Keys.P256dh,
				"auth":   ps.Keys.Auth,
			},
		}
		update["pushSubscription"] = psUpdate
	}
	if input.ClearSubscription != nil {
		update["pushSubscription"] = nil
	}

	if len(update) == 0 {
		return nil, fmt.Errorf("no fields to update")
	}

	_, err = usersColl.UpdateOne(ctx, bson.M{"_id": userID}, bson.M{"$set": update})
	if err != nil {
		return nil, fmt.Errorf("failed to update user: %w", err)
	}

	var user models.User
	err = usersColl.FindOne(ctx, bson.M{"_id": userID}).Decode(&user)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch updated user: %w", err)
	}

	return &user, nil
}

// --- JoinRide ---
func (r *mutationResolver) JoinRide(ctx context.Context, rideCode string, role string) (*models.Ride, error) {
	userIDHex := ctx.Value("userId").(string)
	userID, err := primitive.ObjectIDFromHex(userIDHex)
	if err != nil {
		return nil, fmt.Errorf("invalid userId: %w", err)
	}

	coll := db.GetCollection("bikeapp", "rides")

	var ride models.Ride
	if err := coll.FindOne(ctx, bson.M{"rideCode": rideCode}).Decode(&ride); err != nil {
		if err == mongo.ErrNoDocuments {
			return nil, fmt.Errorf("ride not found")
		}
		return nil, fmt.Errorf("failed to fetch ride: %w", err)
	}

	for _, p := range ride.Participants {
		if p.UserID == userID {
			return &ride, nil
		}
	}

	if len(ride.Participants) >= ride.Settings.MaxRiders {
		return nil, fmt.Errorf("ride is full: max riders = %d", ride.Settings.MaxRiders)
	}

	newParticipant := models.Participant{
		UserID:   userID,
		Role:     role,
		JoinedAt: time.Now().UTC().Format(time.RFC3339),
	}

	update := bson.M{"$push": bson.M{"participants": newParticipant}}
	res := coll.FindOneAndUpdate(
		ctx,
		bson.M{"rideCode": rideCode},
		update,
		options.FindOneAndUpdate().SetReturnDocument(options.After),
	)

	var updated models.Ride
	if err := res.Decode(&updated); err != nil {
		return nil, fmt.Errorf("failed to decode updated ride: %w", err)
	}

	return &updated, nil
}

// --- SendSignal ---
func (r *mutationResolver) SendSignal(ctx context.Context, rideCode string, signalType string, lat *float64, lng *float64) (bool, error) {
	userIDHex := ctx.Value("userId").(string)
	userID, err := primitive.ObjectIDFromHex(userIDHex)
	if err != nil {
		return false, fmt.Errorf("invalid userId: %w", err)
	}

	var location *models.GeoLocation
	if lat != nil && lng != nil {
		location = &models.GeoLocation{Lat: *lat, Lng: *lng}
	}

	signal := models.Signal{
		ID:        primitive.NewObjectID(),
		RideCode:  rideCode,
		FromUser:  userID,
		Type:      signalType,
		Timestamp: time.Now().UTC().Format(time.RFC3339),
		Location:  location,
	}

	coll := db.GetCollection("bikeapp", "signals")
	if _, err := coll.InsertOne(ctx, signal); err != nil {
		return false, err
	}

	return true, nil
}

// --- Participant Field Resolvers ---
func (r *participantResolver) UserID(ctx context.Context, obj *models.Participant) (string, error) {
	return obj.UserID.Hex(), nil
}

// --- Query Resolvers ---
func (r *queryResolver) Me(ctx context.Context) (*models.User, error) {
	userIDHex := ctx.Value("userId").(string)
	userID, err := primitive.ObjectIDFromHex(userIDHex)
	if err != nil {
		return nil, fmt.Errorf("invalid userId: %w", err)
	}

	coll := db.GetCollection("bikeapp", "users")

	var user models.User
	if err := coll.FindOne(ctx, bson.M{"_id": userID}).Decode(&user); err != nil {
		if err == mongo.ErrNoDocuments {
			return nil, errors.New("user not found")
		}
		return nil, err
	}
	return &user, nil
}

// Ride is the resolver for the ride field.
func (r *queryResolver) Ride(ctx context.Context, rideCode string) (*models.Ride, error) {
	coll := db.GetCollection("bikeapp", "rides")

	var ride models.Ride
	if err := coll.FindOne(ctx, bson.M{"rideCode": rideCode}).Decode(&ride); err != nil {
		return nil, err
	}
	return &ride, nil
}

// MyRides is the resolver for the myRides field.
func (r *queryResolver) MyRides(ctx context.Context) ([]*models.Ride, error) {
	userIDHex := ctx.Value("userId").(string)
	userID, err := primitive.ObjectIDFromHex(userIDHex)
	if err != nil {
		return nil, fmt.Errorf("invalid userId: %w", err)
	}

	coll := db.GetCollection("bikeapp", "rides")
	cursor, err := coll.Find(ctx, bson.M{"participants.userId": userID})
	if err != nil {
		return nil, err
	}
	defer cursor.Close(ctx)

	var rides []*models.Ride
	for cursor.Next(ctx) {
		var ride models.Ride
		if err := cursor.Decode(&ride); err != nil {
			return nil, err
		}
		rides = append(rides, &ride)
	}
	return rides, nil
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, userID string) (*models.User, error) {
	coll := db.GetCollection("bikeapp", "users")

	userIDObj, err := primitive.ObjectIDFromHex(userID)
	if err != nil {
		return nil, fmt.Errorf("invalid userId: %w", err)
	}

	var user models.User
	if err := coll.FindOne(ctx, bson.M{"_id": userIDObj}).Decode(&user); err != nil {
		return nil, err
	}
	return &user, nil
}

// UsersByIds is the resolver for the usersByIds field.
func (r *queryResolver) UsersByIds(ctx context.Context, ids []string) ([]*models.User, error) {
	coll := db.GetCollection("bikeapp", "users")

	objectIDs := make([]primitive.ObjectID, 0, len(ids))
	for _, idStr := range ids {
		objID, err := primitive.ObjectIDFromHex(idStr)
		if err != nil {
			return nil, fmt.Errorf("invalid user id: %s, err: %w", idStr, err)
		}
		objectIDs = append(objectIDs, objID)
	}

	cursor, err := coll.Find(ctx, bson.M{"_id": bson.M{"$in": objectIDs}})
	if err != nil {
		return nil, err
	}
	defer cursor.Close(ctx)

	var users []*models.User
	for cursor.Next(ctx) {
		var u models.User
		if err := cursor.Decode(&u); err != nil {
			return nil, err
		}
		users = append(users, &u)
	}

	if err := cursor.Err(); err != nil {
		return nil, err
	}

	return users, nil
}

// --- Ride Field Resolvers ---
func (r *rideResolver) ID(ctx context.Context, obj *models.Ride) (string, error) {
	return obj.ID.Hex(), nil
}

// CreatedBy is the resolver for the createdBy field.
func (r *rideResolver) CreatedBy(ctx context.Context, obj *models.Ride) (string, error) {
	return obj.CreatedBy.Hex(), nil
}

// --- Signal Field Resolvers ---
func (r *signalResolver) ID(ctx context.Context, obj *models.Signal) (string, error) {
	return obj.ID.Hex(), nil
}

// FromUser is the resolver for the fromUser field.
func (r *signalResolver) FromUser(ctx context.Context, obj *models.Signal) (string, error) {
	return obj.FromUser.Hex(), nil
}

// --- User Field Resolvers ---
func (r *userResolver) ID(ctx context.Context, obj *models.User) (string, error) {
	return obj.ID.Hex(), nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Participant returns ParticipantResolver implementation.
func (r *Resolver) Participant() ParticipantResolver { return &participantResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Ride returns RideResolver implementation.
func (r *Resolver) Ride() RideResolver { return &rideResolver{r} }

// Signal returns SignalResolver implementation.
func (r *Resolver) Signal() SignalResolver { return &signalResolver{r} }

// User returns UserResolver implementation.
func (r *Resolver) User() UserResolver { return &userResolver{r} }

type mutationResolver struct{ *Resolver }
type participantResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type rideResolver struct{ *Resolver }
type signalResolver struct{ *Resolver }
type userResolver struct{ *Resolver }
